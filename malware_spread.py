class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)  # Number of nodes in the graph
        colors = [
            -1
        ] * n  # Array to mark the "color" (connected component) of each node
        cl = 0  # Component counter

        # Assign a color (component ID) to each connected component using DFS
        for i in range(n):
            if colors[i] == -1:
                self.dfs(graph, colors, i, cl)
                cl += 1
        # Count the size of each component
        groups = [0] * cl
        for node in colors:
            groups[node] += 1
        # Count how many infected nodes are in each component
        infected = [0] * cl
        for node in initial:
            gr = colors[node]
            infected[gr] += 1
        # Find the node to remove
        result = float("inf")
        for node in initial:
            gr = colors[node]
            if infected[gr] == 1:  # If only one infected node in this component
                if result == float("inf"):
                    result = node
                elif groups[colors[node]] > groups[colors[result]]:
                    result = node
                elif groups[colors[node]] == groups[colors[result]]:
                    result = min(result, node)
        # If no valid node is found, choose the smallest node index
        if result == float("inf"):
            for node in initial:
                result = min(result, node)
        return result

    def dfs(self, graph, colors, i, cl):
        # base case
        # Already visited
        if colors[i] != -1:
            return

        # logic
        # Mark the node with the current component color
        colors[i] = cl
        for j in range(len(graph)):
            if i == j:
                continue
            if graph[i][j] == 1:  # There's an edge between node i and j
                self.dfs(graph, colors, j, cl)


# time complexity is O(V^2) where V is the number of vertices
# space complexity is O(V)
